{"version":3,"sources":["Table.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["SortDirection","initialDatumDelta","JSON","parse","window","localStorage","getItem","datumDeltaReducer","state","action","type","nextState","id","attr","newValue","setItem","stringify","Error","SearchBarRoot","styled","Paper","SearchBarInput","InputBase","SearchBar","query","onChange","e","target","value","fullWidth","placeholder","Root","div","TableCell","MuiTableCell","bold","Table","data","datumKey","boldCellFuncs","upperCaseColumns","useReducer","dataDelta","dispatch","useEffect","useState","setQuery","normalizedQuery","useMemo","toLowerCase","Asc","sortDirection","setSortDirection","sortHeader","setSortHeader","editingCell","setEditingCell","headers","length","firstDatum","Object","keys","map","header","filteredData","result","datum","filter","some","toString","includes","sort","a","b","localeCompare","Desc","reverse","onHeaderClick","getOppositeSortDirection","TableHead","TableRow","key","TableSortLabel","active","direction","onClick","word","charAt","toUpperCase","slice","TableBody","rowId","onBlur","onKeyDown","OutlinedInput","autoFocus","labelWidth","shouldBold","boldFunc","Button","variant","color","createClassRow","subject","numberStudents","averageGrade","dataSets","manufacturer","model","Buttons","App","dataSetIndex","setDataSetIndex","dataSet","className","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8609156b.chunk.js","sourcesContent":["import React, { useMemo, useState, useReducer, useEffect } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport {\r\n  Table as MuiTable,\r\n  TableBody,\r\n  TableCell as MuiTableCell,\r\n  TableHead,\r\n  TableRow,\r\n  Paper,\r\n  InputBase,\r\n  TableSortLabel,\r\n  OutlinedInput,\r\n  Button\r\n} from \"@material-ui/core\";\r\n\r\n// Further things I would do, accept an optional array of headers to display and fallback to\r\n// the current behavior of displaying all keys in the first datum\r\n// Also debouncing input would be nice since it's saving the changes to local storage every change\r\n\r\n// **********\r\n// Handle saving changes made to table\r\n// **********\r\n\r\n// Each change to a field\r\ntype DatumDelta = {\r\n  [key: string]: string | number;\r\n};\r\n\r\n// All rows and their changes\r\ntype DatumDeltas = {\r\n  [key: number]: DatumDelta;\r\n};\r\nconst datumDeltaStorageLocation = \"datumDelta\";\r\n\r\nconst initialDatumDelta = JSON.parse(\r\n  window.localStorage.getItem(datumDeltaStorageLocation) || \"{}\"\r\n) as DatumDeltas;\r\n\r\ntype Action =\r\n  | { type: \"setDelta\"; id: number; attr: string; newValue: string | number }\r\n  | { type: \"resetDeltas\" };\r\n\r\n// Reducer to handle side effect of saving to local storage\r\nconst datumDeltaReducer = (state: DatumDeltas, action: Action) => {\r\n  switch (action.type) {\r\n    case \"setDelta\": {\r\n      const nextState = {\r\n        ...state,\r\n        [action.id]: {\r\n          ...state[action.id],\r\n          [action.attr]: action.newValue\r\n        }\r\n      };\r\n\r\n      window.localStorage.setItem(\r\n        datumDeltaStorageLocation,\r\n        JSON.stringify(nextState)\r\n      );\r\n\r\n      return nextState;\r\n    }\r\n    case \"resetDeltas\": {\r\n      const nextState = {};\r\n      window.localStorage.setItem(\r\n        datumDeltaStorageLocation,\r\n        JSON.stringify({})\r\n      );\r\n\r\n      return nextState;\r\n    }\r\n    default:\r\n      throw new Error();\r\n  }\r\n};\r\n// **********\r\n// General\r\n// **********\r\nenum SortDirection {\r\n  Asc = \"asc\",\r\n  Desc = \"desc\"\r\n}\r\n\r\nconst getOppositeSortDirection = (sortDirection: SortDirection) => {\r\n  if (sortDirection === SortDirection.Asc) {\r\n    return SortDirection.Desc;\r\n  }\r\n\r\n  return SortDirection.Asc;\r\n};\r\n\r\nexport type Datum = {\r\n  [key: string]: string | number;\r\n};\r\n\r\n// Quick help from https://paulund.co.uk/how-to-capitalize-the-first-letter-of-a-string-in-javascript\r\nfunction capitalize(word: string) {\r\n  return word.charAt(0).toUpperCase() + word.slice(1);\r\n}\r\n\r\n// **********\r\n// SearchBar\r\n// **********\r\n\r\nconst SearchBarRoot = styled(Paper)``;\r\n\r\nconst SearchBarInput = styled(InputBase)`\r\n  .MuiInputBase-input {\r\n    padding: 12px;\r\n  }\r\n`;\r\n\r\ntype SearchBarProps = {\r\n  query: string;\r\n  onChange: (value: string) => void;\r\n};\r\n\r\nconst SearchBar: React.FC<SearchBarProps> = ({ query, onChange }) => {\r\n  return (\r\n    <SearchBarRoot>\r\n      <SearchBarInput\r\n        onChange={e => onChange(e.target.value)}\r\n        value={query}\r\n        fullWidth\r\n        placeholder=\"Search...\"\r\n      />\r\n    </SearchBarRoot>\r\n  );\r\n};\r\n\r\n// **********\r\n// Table\r\n// **********\r\n\r\nconst Root = styled.div`\r\n  & > * {\r\n    margin-bottom: 12px;\r\n  }\r\n`;\r\n\r\n// TODO conditionally show hover state for cells that can be hovered and aren't being edited\r\nconst TableCell = styled(MuiTableCell)<{ bold?: boolean }>`\r\n  && {\r\n    &:hover {\r\n      cursor: pointer;\r\n      background: #0000000f;\r\n    }\r\n\r\n    font-weight: ${({ bold }) => (bold ? 700 : 400)};\r\n  }\r\n`;\r\n\r\ntype Props = {\r\n  data: Datum[];\r\n  datumKey: string;\r\n  // Allows fine grain control over bolding cells\r\n  boldCellFuncs?: {\r\n    [key: string]: (value: string | number) => boolean;\r\n  };\r\n  // Which columns to apply an upperCase filter on. Each string is a header\r\n  upperCaseColumns?: string[];\r\n};\r\n\r\nexport const Table: React.FC<Props> = ({\r\n  data,\r\n  datumKey,\r\n  boldCellFuncs,\r\n  upperCaseColumns\r\n}) => {\r\n  const [dataDelta, dispatch] = useReducer(\r\n    datumDeltaReducer,\r\n    initialDatumDelta\r\n  );\r\n\r\n  // On unmount remove any changes, this way it doesn't interfere with the multiple datasets\r\n  // TODO store each set of changes in a unique location for each dataset so this won't be necessary\r\n  useEffect(() => {\r\n    return () => {\r\n      dispatch({\r\n        type: \"resetDeltas\"\r\n      });\r\n    };\r\n  }, []);\r\n\r\n  const [query, setQuery] = useState(\"\");\r\n  // When searching to filter rows, compare against a normalized query, in this case, lowerCased value\r\n  const normalizedQuery = useMemo(() => {\r\n    return query.toLowerCase();\r\n  }, [query]);\r\n\r\n  // Column sorting variables\r\n  const [sortDirection, setSortDirection] = useState<SortDirection>(\r\n    SortDirection.Asc\r\n  );\r\n  const [sortHeader, setSortHeader] = useState<string | null>(null);\r\n\r\n  // Keeps track of which row and column is being edited\r\n  const [editingCell, setEditingCell] = useState<{\r\n    rowId: string | number;\r\n    header: string;\r\n  } | null>(null);\r\n\r\n  // Get a list of all the headers based on the keys in the data provided\r\n  // This makes the table reusable across datasets as demoed by the data set selection buttons\r\n  const headers = useMemo(() => {\r\n    if (data.length) {\r\n      const firstDatum = data[0];\r\n      return Object.keys(firstDatum).map(header => header);\r\n    }\r\n\r\n    return [];\r\n  }, [data]);\r\n\r\n  // Apply changes, filter on query, and sort\r\n  const filteredData = useMemo(() => {\r\n    let result = data\r\n      .map(datum => {\r\n        const id = datum[datumKey] as number;\r\n\r\n        return {\r\n          ...datum,\r\n          ...dataDelta[id]\r\n        };\r\n      })\r\n      .filter(datum => {\r\n        return headers.some(header => {\r\n          const value = datum[header];\r\n\r\n          return (\r\n            value &&\r\n            value\r\n              .toString()\r\n              .toLowerCase()\r\n              .includes(normalizedQuery)\r\n          );\r\n        });\r\n      });\r\n\r\n    if (sortHeader) {\r\n      result = result.sort((a, b) =>\r\n        a[sortHeader].toString().localeCompare(b[sortHeader].toString())\r\n      );\r\n    }\r\n\r\n    if (sortDirection === SortDirection.Desc) {\r\n      result.reverse();\r\n    }\r\n\r\n    return result;\r\n  }, [\r\n    data,\r\n    dataDelta,\r\n    headers,\r\n    normalizedQuery,\r\n    sortHeader,\r\n    sortDirection,\r\n    datumKey\r\n  ]);\r\n\r\n  // Update sort direction/column\r\n  const onHeaderClick = (header: string) => {\r\n    if (header === sortHeader) {\r\n      setSortDirection(getOppositeSortDirection(sortDirection));\r\n    } else {\r\n      setSortDirection(SortDirection.Asc);\r\n    }\r\n\r\n    setSortHeader(header);\r\n  };\r\n\r\n  return (\r\n    <Root>\r\n      <SearchBar query={query} onChange={value => setQuery(value)} />\r\n      <Paper>\r\n        <MuiTable>\r\n          <TableHead>\r\n            <TableRow>\r\n              {headers.map(header => (\r\n                <TableCell key={header}>\r\n                  <TableSortLabel\r\n                    active={sortHeader === header}\r\n                    direction={sortDirection}\r\n                    onClick={() => onHeaderClick(header)}\r\n                  >\r\n                    {capitalize(header)}\r\n                  </TableSortLabel>\r\n                </TableCell>\r\n              ))}\r\n            </TableRow>\r\n          </TableHead>\r\n          <TableBody>\r\n            {filteredData.map(datum => {\r\n              const id = datum[datumKey] as number;\r\n\r\n              return (\r\n                <TableRow key={id}>\r\n                  {headers.map(header => {\r\n                    let value = datum[header].toString();\r\n\r\n                    if (\r\n                      editingCell &&\r\n                      editingCell.rowId === id &&\r\n                      editingCell.header === header\r\n                    ) {\r\n                      // Render the editable cell\r\n                      return (\r\n                        <TableCell\r\n                          key={header}\r\n                          onBlur={() => setEditingCell(null)}\r\n                          onKeyDown={e => {\r\n                            if (e.key === \"Enter\") {\r\n                              setEditingCell(null);\r\n                            }\r\n                          }}\r\n                        >\r\n                          <OutlinedInput\r\n                            value={value}\r\n                            autoFocus\r\n                            labelWidth={0}\r\n                            onChange={e => {\r\n                              dispatch({\r\n                                type: \"setDelta\",\r\n                                attr: header,\r\n                                id,\r\n                                newValue: e.target.value\r\n                              });\r\n                            }}\r\n                          />\r\n                        </TableCell>\r\n                      );\r\n                    } else {\r\n                      // Render the normal cell\r\n                      let shouldBold = false;\r\n\r\n                      if (\r\n                        upperCaseColumns &&\r\n                        upperCaseColumns.includes(header)\r\n                      ) {\r\n                        value = value.toUpperCase();\r\n                      }\r\n\r\n                      if (boldCellFuncs) {\r\n                        const boldFunc = boldCellFuncs[header];\r\n                        if (boldFunc) {\r\n                          shouldBold = boldFunc(value);\r\n                        }\r\n                      }\r\n\r\n                      return (\r\n                        <TableCell\r\n                          key={header}\r\n                          bold={shouldBold}\r\n                          onClick={() => {\r\n                            // Dont let the user change the identifying key\r\n                            if (header !== datumKey) {\r\n                              setEditingCell({\r\n                                rowId: datum[datumKey],\r\n                                header\r\n                              });\r\n                            }\r\n                          }}\r\n                        >\r\n                          {value}\r\n                        </TableCell>\r\n                      );\r\n                    }\r\n                  })}\r\n                </TableRow>\r\n              );\r\n            })}\r\n          </TableBody>\r\n        </MuiTable>\r\n      </Paper>\r\n      <Button\r\n        variant=\"contained\"\r\n        color=\"primary\"\r\n        onClick={() =>\r\n          dispatch({\r\n            type: \"resetDeltas\"\r\n          })\r\n        }\r\n      >\r\n        Reset Changes\r\n      </Button>\r\n    </Root>\r\n  );\r\n};\r\n\r\nexport default Table;\r\n","import React, { useState, useMemo } from \"react\";\nimport \"./App.css\";\nimport Table, { Datum } from \"./Table\";\nimport { Button } from \"@material-ui/core\";\nimport styled from \"styled-components\";\n\nconst automobiles: Datum[] = [\n  {\n    id: 1,\n    manufacturer: \"Ford\",\n    model: \"Focus\"\n  },\n  {\n    id: 2,\n    manufacturer: \"Ford\",\n    model: \"Mustang\"\n  },\n  {\n    id: 3,\n    manufacturer: \"Ford\",\n    model: \"F-150\"\n  },\n  {\n    id: 4,\n    manufacturer: \"Chevrolet\",\n    model: \"Corvette\"\n  },\n  {\n    id: 5,\n    manufacturer: \"Chevrolet\",\n    model: \"Equinox\"\n  },\n  {\n    id: 6,\n    manufacturer: \"Tesla\",\n    model: \"Model 3\"\n  },\n  {\n    id: 7,\n    manufacturer: \"Toyota\",\n    model: \"Camry\"\n  },\n  {\n    id: 8,\n    manufacturer: \"Dodge\",\n    model: \"Charger\"\n  },\n  {\n    id: 9,\n    manufacturer: \"Dodge\",\n    model: \"Challenger\"\n  }\n];\n\nconst createClassRow = (\n  id: number,\n  subject: string,\n  numberStudents: number,\n  averageGrade: number\n) => {\n  return {\n    id,\n    subject,\n    numberStudents,\n    averageGrade\n  };\n};\n\nconst classes: Datum[] = [\n  createClassRow(1, \"Math\", 23, 3.4),\n  createClassRow(2, \"Science\", 12, 2.8),\n  createClassRow(3, \"English\", 23, 2.9),\n  createClassRow(4, \"Social\", 23, 3.8),\n  createClassRow(5, \"Gym\", 23, 2.1),\n  createClassRow(6, \"Music\", 23, 1.9)\n];\n\nconst dataSets = [automobiles, classes];\n\nconst Buttons = styled.div`\n  display: flex;\n  margin-bottom: 12px;\n  && > * {\n    margin-right: 12px;\n  }\n`;\n\nconst App: React.FC = () => {\n  const [dataSetIndex, setDataSetIndex] = useState(0);\n  const dataSet = useMemo(() => {\n    return dataSets[dataSetIndex];\n  }, [dataSetIndex]);\n\n  return (\n    <div className=\"App\">\n      <Buttons>\n        <Button\n          variant={dataSetIndex === 0 ? \"contained\" : \"outlined\"}\n          color=\"secondary\"\n          onClick={() => setDataSetIndex(0)}\n        >\n          Data set 1\n        </Button>\n        <Button\n          variant={dataSetIndex === 1 ? \"contained\" : \"outlined\"}\n          onClick={() => setDataSetIndex(1)}\n          color=\"secondary\"\n        >\n          Data set 2\n        </Button>\n      </Buttons>\n\n      <Table\n        key={dataSetIndex}\n        data={dataSet}\n        datumKey=\"id\"\n        boldCellFuncs={{\n          manufacturer: value => value.toString().toLowerCase() === \"ford\"\n        }}\n        upperCaseColumns={[\"model\"]}\n      />\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}